/***************************************************************************
 # Copyright (c) 2023, NVIDIA CORPORATION.  All rights reserved.
 #
 # NVIDIA CORPORATION and its licensors retain all intellectual property
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
 **************************************************************************/

#pragma once

#include "rtx/utility/common.slangh"
#include "rtx/utility/noise.slangh"
#include "rtx/utility/froxel.slangh"
#include "rtx/concept/ray/ray.slangh"
#include "rtx/concept/volume/volume.slangh"
#include "rtx/algorithm/rtxdi/rtxdi.slangh"

uvec3 worldPosToFroxelIndex(const VolumeDefinitionCamera camera, const VolumeArgs volumeArgs, float3 worldPos)
{
  const vec3 translatedWorldPosition = worldToTranslatedWorld(camera, worldPos);
    // Note: Lookup lighting at the specified position in the volume radiance cache by calculating its UVW coordinates. Jittered matrix used
    // here due to Surface Interaction assumptions stated in function documentation.
  const vec3 virtualFroxelUVW = translatedWorldPositionToFroxelUVW(
      camera.translatedWorldToView, camera.translatedWorldToProjectionJittered, packedFlagGet(camera.flags, rightHandedFlag),
      volumeArgs.restirFroxelDepthSlices, volumeArgs.froxelDepthSliceDistributionExponent, volumeArgs.froxelMaxDistance, camera.nearPlane,
      translatedWorldPosition);

  const uvec3 froxelDimensions = uvec3(volumeArgs.restirFroxelGridDimensions, volumeArgs.restirFroxelDepthSlices);
  
  return saturate(virtualFroxelUVW) * (froxelDimensions - 1);
}

bool spatialVisibilityReuse(const VolumeArgs volumeArgs, int3 start, int3 end, uint16_t lightIndex)
{
  if(all(start == end))
  {
    return false;
  }
  
  int3 delta = abs(end - start);
  int3 step = sign(end - start);
    
  int maxDistance = max(delta.x, max(delta.y, delta.z));
  float3 error = float3(maxDistance / 2, maxDistance / 2, maxDistance / 2);
    
  const uint3 froxelDimensions = uvec3(volumeArgs.restirFroxelGridDimensions, volumeArgs.restirFroxelDepthSlices);
  int3 current = start;
    
  for (int i = 0; i <= maxDistance; i++)
  {
    // Check if current position is within bounds
    if (any(current < 0) || any(current >= froxelDimensions))
    {
      return false; // Out of bounds, stop execution and return false
    }
        
    // Load neighbour reservoir
    VolumeReSTIR_PackedReservoir packedReservoir;
    packedReservoir.data0 = VolumeReservoirs[current];
    VolumeReSTIR_Reservoir neighborReservoir = VolumeReSTIR_Reservoir::createFromPacked(packedReservoir);

    if(neighborReservoir.isValid() && neighborReservoir.knownVisible && neighborReservoir.lightSample.lightIndex == lightIndex)
    {
      return true;
    }
        
    error -= delta;
        
    if (error.x < 0)
    {
      current.x += step.x;
      error.x += maxDistance;
    }
    if (error.y < 0)
    {
      current.y += step.y;
      error.y += maxDistance;
    }
    if (error.z < 0)
    {
      current.z += step.z;
      error.z += maxDistance;
    }
  }
    
  return false; // Reached the edge and nothing has been found
}

// Ray-frustum intersection function assuming origin is inside the frustum
float rayFrustumIntersection(const VolumeDefinitionCamera camera, float3 origin, float3 direction)
{
   float tFar = floatMax;

   for (int i = 0; i < 6; i++)
   {
     float4 plane = camera.worldPlanes[i];
     float denom = dot(direction, plane.xyz);
     
     // We only need to check for exit points
     if (denom > 0)
     {
       float t = -(dot(origin, plane.xyz) + plane.w) / denom;
       tFar = min(tFar, t);
     }
   }

   return tFar;
}

void VolumeReSTIR_SpatialVisibilityReuse(const VolumeArgs volumeArgs, const VolumeDefinitionCamera camera, const RAB_VolumeInteraction rabVolumeInteraction, float3 froxelCoordinate, inout VolumeReSTIR_Reservoir currentVolumeReservoir)
{
  if(!volumeArgs.enablevisibilityReuse || currentVolumeReservoir.knownVisible || !currentVolumeReservoir.isValid())
    return;
    
  const vec3 froxelTranslatedWorldPosition = froxelCoordinateToTranslatedWorldPosition(
      camera.projectionToTranslatedWorld, camera.viewToProjection, packedFlagGet(camera.flags, rightHandedFlag),
      volumeArgs.restirInverseFroxelGridDimensions, volumeArgs.restirFroxelDepthSlices,
      volumeArgs.froxelDepthSliceDistributionExponent, volumeArgs.froxelMaxDistance, camera.nearPlane,
      froxelCoordinate);
  const vec3 froxelWorldPosition = translatedWorldToWorld(camera, froxelTranslatedWorldPosition);
      
  RAB_LightSample rabLightSample;
  float inverseSelectionPdf;
  const bool lightSampleValid = VolumeReSTIR_GetLightSample(
        currentVolumeReservoir, rabVolumeInteraction,
        rabLightSample, inverseSelectionPdf);
    
  const float3 lightDirection = normalize(froxelTranslatedWorldPosition - worldToTranslatedWorld(camera, rabLightSample.position));
  const float edgeT = rayFrustumIntersection(camera, froxelTranslatedWorldPosition, lightDirection);
  const uint3 edgeFroxelIndex = worldPosToFroxelIndex(camera, volumeArgs, froxelTranslatedWorldPosition + lightDirection * edgeT);
    
  currentVolumeReservoir.knownVisible = spatialVisibilityReuse(volumeArgs, froxelCoordinateToFroxelIndex(froxelCoordinate), edgeFroxelIndex, currentVolumeReservoir.lightSample.lightIndex);
}

void volume_restir_pass(ivec3 threadIndex)
{
  VolumeArgs volumeArgs = cb.volumeArgs;
  
  const uvec3 froxelDimensions = uvec3(volumeArgs.restirFroxelGridDimensions, volumeArgs.restirFroxelDepthSlices);
  const uint froxelVolume = threadIndex.x / froxelDimensions.x;

  if (any(threadIndex.yz >= froxelDimensions.yz) || froxelVolume > volumeArgs.numActiveFroxelVolumes)
  {
    return;
  }

  const VolumeDefinitionCamera camera = cb.volumeArgs.restirCameras[froxelVolume];

  // Construct RNG

  // Note: Bounce iteration multiplied by a heuristic used to offset the seed for each bounce. This is done so that
  // each depth slice for a specific froxel x/y coordinate can be treated as if they were sampled in a raymarched way,
  // hypothetically carrying the random state across them. This might not be the best way to do it but seems to work better
  // than any other strategy (factoring Z into the X/Y coordinates causes regular patterns, adding Z to the frame index
  // causes temporal smearing). This may be able to be improved in the future though as it still produces somewhat regular looking
  // samples visually (just not as bad as before).
  // Heuristic justification: 3ish samples for each RIS sample, plus 3ish for other logic and sample merging, and finally this is
  // done once for each reservoir sample, using the maximum amount of them as a conservative estimate.
  const uint approxRNGSamplesPerDepthSlice = (cb.volumeRISTotalSampleCount * 3 + 3);
  //RNG rng = createRNG(uvec2(threadIndex.x, threadIndex.y), cb.frameIdx, threadIndex.z * approxRNGSamplesPerDepthSlice);
  // Note: Volume ReSTIR RAB random state used here now instead to not be as costly as having two random samplers. If this creates
  // issues try moving back to the original spatiotemporal blue noise. Do note this makes the volumetric random unaffected by the
  // white noise override sadly (though this could be modified in the RTXDI Application Bridge to be consistent with the rest of
  // our project's random).
  RAB_RandomSamplerState rabRandomState = RAB_InitRandomSampler(
    uvec2(threadIndex.x, threadIndex.y), cb.frameIdx,
    threadIndex.z * approxRNGSamplesPerDepthSlice);

  // Calculate the froxel coordinate for the current thread's index
  // Note: This coordinate represents the center of a froxel.

  uvec3 froxelIndex = threadIndex;
  froxelIndex.x = threadIndex.x - froxelVolume * froxelDimensions.x;
  const vec3 froxelCoordinate = froxelIndexToFroxelCoordinate(froxelIndex);

  // Calculate a froxel coordinate sampling offset for the current froxel

  const f16vec3 randomSample = f16vec3(RAB_GetNextRandom(rabRandomState), RAB_GetNextRandom(rabRandomState), RAB_GetNextRandom(rabRandomState));
  const f16vec3 currentFroxelCoordinateOffset = calcUniformCenteredCubePositionSample(randomSample);
  
  // Note: Jittered by coordinate offset which samples outwards from the center of the froxel cell uniformly (though will translate
  // to a slightly nonuniform sampling pattern in worldspace).
  const vec3 currentFroxelCoordinate = froxelCoordinate + currentFroxelCoordinateOffset * 0.5.xxx;
  const vec3 currentFroxelTranslatedWorldPosition = froxelCoordinateToTranslatedWorldPosition(
    camera.projectionToTranslatedWorld, camera.viewToProjection, packedFlagGet(camera.flags, rightHandedFlag),
    volumeArgs.restirInverseFroxelGridDimensions, volumeArgs.restirFroxelDepthSlices,
    volumeArgs.froxelDepthSliceDistributionExponent, volumeArgs.froxelMaxDistance, camera.nearPlane,
    currentFroxelCoordinate);
  const vec3 currentFroxelWorldPosition = translatedWorldToWorld(camera, currentFroxelTranslatedWorldPosition);

  // Calculate the distance from the camera to the center of the froxel

  // Note: While the froxel position is in translated world space, this is simply the length of the vector (implicitly from the origin).
  const float currentFroxelDistance = length(currentFroxelTranslatedWorldPosition);

  // Create a Ray to the current froxel position

  // Todo: Improve with some way to construct a volume ray direction manually from a position?
  Ray ray;
  ray.coneRadius = float16_t(0.0f);
  ray.spreadAngle = float16_t(cb.screenSpacePixelSpreadHalfAngle);

  // Create a Ray Interaction for the current froxel

  // Todo: Improve with some way to construct a volume hit manually like this
  MinimalRayInteraction minimalRayInteraction;
  minimalRayInteraction.coneRadius = ray.coneRadius + float16_t(ray.spreadAngle * currentFroxelDistance);

  // Create a Volume Interaction for the current froxel

  // Note: Volume Interaction constructed with non-translated world position for now, may not be as accurate but must be done
  // since the rest of the renderer is not using translated world space for the time being.
  const VolumeInteraction volumeInteraction = volumeInteractionCreate(currentFroxelWorldPosition);

  // Integrate the Volume
  const uvec3 froxelVolumeOffset = uvec3(volumeArgs.restirFroxelGridDimensions.x * froxelVolume, 0, 0);

  // Create wrapper structs for Volume ReSTIR API

  VolumeReSTIR_Parameters volumeParameters;
  volumeParameters.volumeRISTotalSampleCount = cb.volumeRISTotalSampleCount;
  volumeParameters.enableVolumeRISInitialVisibility = volumeArgs.enableVolumeRISInitialVisibility != 0;

  RAB_VolumeInteraction rabVolumeInteraction;
  rabVolumeInteraction.volumeInteraction = volumeInteraction;

  RAB_VolumeVisibilityContext rabVolumeVisibilityContext;
  rabVolumeVisibilityContext.ray = ray;
  rabVolumeVisibilityContext.minimalRayInteraction = minimalRayInteraction;

#if VOLUME_RESTIR_MODE == INITIAL
  // Create a current Volume Reservoir to merge samples into

  VolumeReSTIR_Reservoir currentVolumeReservoir = VolumeReSTIR_SampleLightRIS(
      rabRandomState, rabVolumeVisibilityContext, rabVolumeInteraction, volumeParameters);

  // Perform an initial visiblity check

  if (volumeParameters.enableVolumeRISInitialVisibility && currentVolumeReservoir.isValid())
  {
    RAB_LightSample rabLightSample;
    float inverseSelectionPdf;
    const bool lightSampleValid = VolumeReSTIR_GetLightSample(
      currentVolumeReservoir, rabVolumeInteraction,
      rabLightSample, inverseSelectionPdf);
    
    // Note: Currently set to the invalid Ray Portal index until we support cross-portal lighting here.
    uint8_t sampledTransportPortalIndex = RTXDI_INVALID_PORTAL_INDEX;
    float16_t3 attenuation = float16_t3(0.0f);
    const bool visible = lightSampleValid && RAB_VolumeReSTIR_TraceNEEVisibility(
      rabLightSample, sampledTransportPortalIndex,
      rabVolumeVisibilityContext, rabVolumeInteraction, attenuation);
  
    // Update the reservoir if we know the sample to be visible here.
    currentVolumeReservoir.knownVisible = visible && any(attenuation > float16_t3(0.0f));
  }
  
  // Write out the reservoir containing initial sample and conservative visibility info
  const VolumeReSTIR_PackedReservoir packedReservoir = currentVolumeReservoir.pack();
  VolumeReservoirs[froxelIndex + froxelVolumeOffset] = packedReservoir.data0;
#endif
  
#if VOLUME_RESTIR_MODE == VISIBILITY
  VolumeReSTIR_PackedReservoir packedReservoir;

  // Note: Nearest reservoir to the  position read, potentially jittering this in the future may help accumulate better data (the jittering
  // could be done by the reprojection itself as that is potentially part of that logic as well to distribute samples temporally a bit more).
  packedReservoir.data0 = VolumeReservoirs[froxelIndex + froxelVolumeOffset];

  VolumeReSTIR_Reservoir currentVolumeReservoir = VolumeReSTIR_Reservoir::createFromPacked(packedReservoir);

  VolumeReSTIR_SpatialVisibilityReuse(volumeArgs, camera, rabVolumeInteraction, froxelCoordinate, currentVolumeReservoir);

  VolumeReservoirs[froxelIndex + froxelVolumeOffset] = currentVolumeReservoir.pack().data0;
#endif
  
#if VOLUME_RESTIR_MODE == TEMPORAL
  // Calculate previous froxel related coordinate values
  // Note: This is done by calculating the translated world space position of the desired location in the froxel grid to reproject into the previous
  // frame, then transforming that translated world position back into a froxel UVW coordinates with respect to the previous frame's transforms.
  // Additionally, non-jittered (TAA/DLSS jittering, that is) matrices are used in this process as DLSS's jittering only causes excess blurring since we
  // accumulate and filter the signal ourselves (rather than giving a raw noisy jittered signal to DLSS as intended). This is similar to the issue
  // of giving a jittered signal to a denoiser before DLSS can work with it that we currently also deal with (due to the denoiser working in low res pixels
  // rather than high resolution samples).

  // Note: The previous froxel coordinate/index are only valid if the Froxel UVW coordinate is valid (meaning successful reprojection).
  bool previousVolumeExists, reprojectionValid;
  VolumeLookup previousFroxelLookup = froxelCoordinateToPrev(volumeArgs, volumeArgs.restirFroxelDepthSlices, cb.teleportationPortalIndex, froxelCoordinate, froxelVolume, previousVolumeExists, reprojectionValid);
  
  uvec3 previousFroxelIndex = froxelCoordinateToFroxelIndex(previousFroxelLookup.coordinate);
  
  // Permutation sampling randomizes the previous reservoir buffer
  RTXDI_ApplyPermutationSampling(previousFroxelIndex.xy, uintHash(cb.frameIdx), 2);
  previousFroxelIndex.xy = clamp(previousFroxelIndex.xy, 0, froxelDimensions.xy-1);
  
  // Readjust coordinate after permutation sampling applies
  previousFroxelLookup.coordinate = froxelIndexToFroxelCoordinate(previousFroxelIndex);
  
  // Calculate clamped previous froxel related coordinate values
  // Note: These values are like the typical previous froxel coordinates, but clamped to be within the froxel grid.

  const uvec3 previousFroxelVolumeOffset = uvec3(volumeArgs.restirFroxelGridDimensions.x * previousFroxelLookup.volumeIndex, 0, 0);
  
  // Note: Left uninitialized as it will be written to in all paths when reprojecting existing temporal reservoirs.
  VolumeReSTIR_Reservoir oldVolumeReservoir = VolumeReSTIR_Reservoir::createEmpty();

  if (previousVolumeExists && reprojectionValid)
  {
    // Read previous volume reservoir

    VolumeReSTIR_PackedReservoir packedReservoir;

    // Note: Nearest reservoir to the previous position read, potentially jittering this in the future may help accumulate better data (the jittering
    // could be done by the reprojection itself as that is potentially part of that logic as well to distribute samples temporally a bit more).
    packedReservoir.data0 = PrevVolumeReservoirs[previousFroxelIndex + previousFroxelVolumeOffset];

    oldVolumeReservoir = VolumeReSTIR_Reservoir::createFromPacked(packedReservoir);
  }
  
  VolumeReSTIR_PackedReservoir packedReservoir;

  // Note: Nearest reservoir to the  position read, potentially jittering this in the future may help accumulate better data (the jittering
  // could be done by the reprojection itself as that is potentially part of that logic as well to distribute samples temporally a bit more).
  packedReservoir.data0 = VolumeReservoirs[froxelIndex + froxelVolumeOffset];

  VolumeReSTIR_Reservoir currentVolumeReservoir = VolumeReSTIR_Reservoir::createFromPacked(packedReservoir);

  VolumeReSTIR_SpatialVisibilityReuse(volumeArgs, camera, rabVolumeInteraction, froxelCoordinate, currentVolumeReservoir);

  if(volumeArgs.enableVolumeRISInitialVisibility != 0 && !currentVolumeReservoir.knownVisible)
  {
    currentVolumeReservoir.invalidate();
  }
  
  // Handle temporal resampling

  // Note: We only disable this codepath when temporal resampling is disabled as hopefully constant folding will optimize out the rest of
  // the code fetching a previous volume reservoir and doing a light index remapping. Generally this will not often be disabled much anyways,
  // as this option is mostly to be used for debugging and visual comparison.
  if (volumeArgs.enableVolumeTemporalResampling && previousVolumeExists && reprojectionValid && oldVolumeReservoir.isValid())
  {
    currentVolumeReservoir = VolumeReSTIR_TemporalResampling(rabRandomState, 
                                                             rabVolumeVisibilityContext, 
                                                             rabVolumeInteraction, 
                                                             previousFroxelLookup.worldPos,
                                                             1.f, 
                                                             cb.volumeTemporalReuseMaxSampleCount, 
                                                             currentVolumeReservoir, 
                                                             oldVolumeReservoir);
  }

  // Write the new accumulated reservoir out
  // Note: The reservoir may be invalid here and thus have a nonsense sample count, but it is important to write it out fully anyways
  // so that the weight is set to 0 in the reservoir buffer so the next frame's temporal resampling can recognize this (as the invalid
  // sample count won't matter if the weight is 0, just keep this in mind if ever looking at a debug view of the sample count as it may
  // have values wildly out of the usual range).

  VolumeReservoirs[froxelIndex + froxelVolumeOffset] = currentVolumeReservoir.pack().data0;
#endif
  
#if VOLUME_RESTIR_MODE == SPATIAL_REUSE
  // Spatial
  VolumeReSTIR_PackedReservoir packedReservoir;
  packedReservoir.data0 = PrevVolumeReservoirs[froxelIndex + froxelVolumeOffset];
  
  if(volumeArgs.enableVolumeSpatialResampling)
  {
    VolumeReSTIR_Reservoir centerVolumeReservoir = VolumeReSTIR_Reservoir::createFromPacked(packedReservoir);
    
    VolumeReSTIR_Reservoir spatialVolumeReservoir = VolumeReSTIR_SpatialResampling(rabRandomState, 
                                                                                   volumeArgs,
                                                                                   camera,
                                                                                   rabVolumeVisibilityContext, 
                                                                                   rabVolumeInteraction, 
                                                                                   centerVolumeReservoir, 
                                                                                   PrevVolumeReservoirs,
                                                                                   froxelDimensions,
                                                                                   froxelIndex,
                                                                                   froxelVolumeOffset,
                                                                                   volumeArgs.numSpatialSamples,
                                                                                   volumeArgs.spatialSamplingRadius);
    
    packedReservoir = spatialVolumeReservoir.pack();
  }
  
  VolumeReservoirs[froxelIndex + froxelVolumeOffset] = packedReservoir.data0;
#endif
}
